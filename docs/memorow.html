<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>暗記ツール</title>

  <style>
    /* ---------- 画面全体 ---------- */
    body { font-family: sans-serif; padding: 20px; }
    textarea { width: 100%; height: 100px; font-size: .9rem; }
    button { font-size: .9rem; margin: 5px 3px; }

    /* ---------- 行ブロック ---------- */
    .line-block {
      border: 1px solid #aaa;
      padding: 5px 15px;
      margin: 10px 0;
      background: #f9f9f9;
      display: flex;
      flex-wrap: wrap;
      cursor: pointer;
      transition: background-color .2s, border .2s;
      user-select: none;
    }

    /* ロック済み行（クリック不可・余白縮小） */
    .locked-line {
      background: #fff !important;
      border: none !important;
      padding: 0 !important;
      margin: 0 !important;
      cursor: default;
    }

    /* ---------- 語句スパン ---------- */
    .inline-item {
      margin: 3px;
      padding: 6px 10px;
      background: #eee;
      border: 1px solid #888;
      cursor: pointer;
      transition: border .2s, padding .2s;
      user-select: none;
    }

    /* 結合完了語句（装飾オフ） */
    .merged {
      background: #fff !important;
      border: none !important;
      padding: 0 !important;
    }

    /* 結合進行中語句（薄青ハイライト） */
    .in-progress {
      background: #d0ebff !important;
      display: block;
      width: 100%;
    }

    /* 誤答ハイライト */
    .incorrect-line, .incorrect {
      background: #ffd6d6 !important;
      animation: flashRed .3s ease-in-out;
    }

    /* 全問正解時のフラッシュ */
    body.flash-success { animation: flashGreen .8s ease-in-out; }

    @keyframes flashGreen { 0% { background:#d4edda; } 100% { background:white; } }
    @keyframes flashRed   { 0% { background:#ffd6d6; } 100% { background:#eee;    } }
  </style>
</head>

<body>
  <h3>暗記ツール</h3>

  <!-- 入力テキスト or ファイル読込 -->
  <div><input type="file" id="fileInput" accept=".txt" /></div>
  <textarea id="inputText" placeholder="例: これは@@最初の@@文です
次の@@行です"></textarea><br/>

  <!-- 操作ボタン -->
  <button id="startBtn">スタート</button>
  <button id="showBtn">問題文表示</button>

  <!-- ゲームエリア -->
  <div id="gameArea"></div>

<script>
/* ---------------------------------------------
   行選択 ＋ 語句結合ツール本体
   変更点：
     ・語句クリック時の stopPropagation を削除し
       行クリックとのバブル共存を許可
----------------------------------------------*/
"use strict";

/* ---------- 変数 ---------- */
let originalData = [];           // 元の2次元配列データ
let currentTargetIndex = 0;      // 今ロックすべき行インデックス
const lineClickHandlers = new Map(); // 行に紐づくクリックHandler

/* ---------- ユーティリティ ---------- */
function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

/* ---------- DOM要素 ---------- */
const fileInput = document.getElementById("fileInput");
const inputText = document.getElementById("inputText");
const startBtn  = document.getElementById("startBtn");
const showBtn   = document.getElementById("showBtn");
const gameArea  = document.getElementById("gameArea");

/* ---------- ファイル読込 ---------- */
fileInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => { inputText.value = ev.target.result; };
  reader.readAsText(file, "UTF-8");
});

/* ---------- ゲーム開始 ---------- */
function startGame() {
  const text = inputText.value.trim();
  if (!text) return;

  /* 初期化 */
  currentTargetIndex = 0;
  originalData = text.split("\n").map(l => l.split("@@"));
  gameArea.innerHTML = "";
  lineClickHandlers.clear();

  /* 行シャッフル */
  const shuffled = [...originalData];
  shuffleArray(shuffled);

  /* 行生成 */
  shuffled.forEach(line => {
    const lineDiv = document.createElement("div");
    lineDiv.className = "line-block";
    lineDiv.dataset.index = originalData.indexOf(line); // 正解位置

    /* 行クリックハンドラ登録 */
    const handler = () => onLineClick(lineDiv);
    lineClickHandlers.set(lineDiv, handler);
    lineDiv.addEventListener("click", handler);

    /* 語句シャッフル（先頭は固定） */
    const [head, ...rest] = line;
    const restShuffled = [...rest];
    shuffleArray(restShuffled);

    /* 語句スパン生成 */
    [head, ...restShuffled].forEach(word => {
      const span = document.createElement("span");
      span.className     = "inline-item";
      span.textContent   = word;
      span.dataset.words = word; // 結合済み文字列

      /* ★ stopPropagation を削除して行クリックと共存させる */
      span.addEventListener("click", () => onWordClick(span));

      lineDiv.appendChild(span);
    });

    gameArea.appendChild(lineDiv);
  });

  /* 入力枠を隠す・スタイル初期反映 */
  inputText.style.display = "none";
  refreshStyles();

  /* ---------- 自動ロック判定 ---------- */
  checkAutoLock();
}

startBtn.addEventListener("click", startGame);
showBtn.addEventListener("click", () => { inputText.style.display = "block"; });

/* ---------- 行クリック処理 ---------- */
function onLineClick(lineDiv) {
  /* 既にロックなら無視 */
  if (lineDiv.classList.contains("locked-line")) return;

  const expected = currentTargetIndex;
  const actual   = Number(lineDiv.dataset.index);

  /* 正しい行？ */
  if (actual === expected) {
    lockLine(lineDiv); // 手動ロック

    /* 行が語句結合済みならターゲット進行 */
    const first = lineDiv.querySelector(".inline-item");
    const mergedLine =
      lineDiv.querySelectorAll(".inline-item").length === 1 &&
      first.dataset.words === originalData[actual].join("@@");

    if (mergedLine) {
      currentTargetIndex++;
      if (currentTargetIndex === originalData.length && allMerged()) {
        flashSuccess();
      }
    }

    refreshStyles();
    checkAutoLock(); // 次行の自動ロック判定
  } else {
    /* 誤クリック時のエフェクト */
    lineDiv.classList.add("incorrect-line");
    setTimeout(() => lineDiv.classList.remove("incorrect-line"), 500);
  }
}

/* ---------- 行ロック処理 ---------- */
function lockLine(lineDiv) {
  /* スタイル更新 */
  lineDiv.classList.add("locked-line");
  lineDiv.style.cursor = "default";

  /* 行クリック無効化 */
  const handler = lineClickHandlers.get(lineDiv);
  if (handler) {
    lineDiv.removeEventListener("click", handler);
    lineClickHandlers.delete(lineDiv);
  }

  /* 正しい位置へ移動 */
  gameArea.insertBefore(lineDiv, gameArea.children[currentTargetIndex]);

  /* ロック直後にチェック */
  refreshStyles();
}

/* ---------- 語句クリック処理 ---------- */
function onWordClick(span) {
  const lineDiv = span.parentNode;

  /* 未ロック行では語句結合できない → 代わりに行クリックが発火する */
  if (!lineDiv.classList.contains("locked-line")) return;

  const lineIdx    = Number(lineDiv.dataset.index);
  const answer     = originalData[lineIdx];
  const firstSpan  = lineDiv.querySelector(".inline-item");
  const currentArr = firstSpan.dataset.words.split("@@");
  const nextWord   = answer[currentArr.length]; // 次に結合すべき語句

  /* 先頭 or 既に結合済みなら無視 */
  if (span === firstSpan || span.classList.contains("merged")) return;

  if (span.textContent === nextWord) {
    /* 正しい語句を選択 → 結合 */
    firstSpan.dataset.words += "@@" + nextWord;
    firstSpan.textContent   += nextWord;
    lineDiv.removeChild(span); // スパン削除
    refreshStyles();

    /* 行が完全結合？ & 現ターゲット行？ */
    const allMergedInLine =
      firstSpan.dataset.words === answer.join("@@") &&
      lineDiv.querySelectorAll(".inline-item").length === 1;

    if (allMergedInLine && lineIdx === currentTargetIndex) {
      currentTargetIndex++;     // 次の行へ
      refreshStyles();
      if (currentTargetIndex === originalData.length && allMerged()) {
        flashSuccess();
      }
      checkAutoLock();          // 進行後の自動ロック判定
    }
  } else {
    /* 誤った語句をクリック */
    span.classList.add("incorrect");
    setTimeout(() => span.classList.remove("incorrect"), 500);
  }
}

/* ---------- 自動ロック判定 ---------- */
function checkAutoLock() {
  while (true) {
    const lineDiv = gameArea.children[currentTargetIndex];
    if (!lineDiv) break; // 末尾

    const idx       = Number(lineDiv.dataset.index);
    const wordCount = lineDiv.querySelectorAll(".inline-item").length;
    const isLocked  = lineDiv.classList.contains("locked-line");
    const visualIdx = [...gameArea.children].indexOf(lineDiv);

    /* 条件
         1. 表示位置 === 正しい行
         2. 未ロック
         3. 語句が2語以上
       → 自動ロック                                   */
    if (idx === currentTargetIndex &&
        visualIdx === currentTargetIndex &&
        !isLocked &&
        wordCount > 1) {
      lockLine(lineDiv);  // 自動ロック
    } else {
      break; // 条件を満たさなくなったら終了
    }
  }
}

/* ---------- スタイル＆進行状況を更新 ---------- */
function refreshStyles() {
  const lines = [...gameArea.children];
  let allPrevMerged = true;

  lines.forEach((lineDiv, visualIdx) => {
    const idx        = Number(lineDiv.dataset.index);
    const items      = lineDiv.querySelectorAll(".inline-item");
    const first      = items[0];
    const currentStr = first ? first.dataset.words : "";
    const correctStr = originalData[idx].join("@@");

    /* リセット */
    items.forEach(el => el.classList.remove("in-progress", "merged"));

    /* 全結合済み行？ */
    const fullyMerged =
      items.length === 1 &&
      currentStr === correctStr &&
      visualIdx === idx &&
      allPrevMerged;

    if (fullyMerged) {
      first.classList.add("merged");
    } else if (
      allPrevMerged &&
      visualIdx === idx &&
      correctStr.startsWith(currentStr) &&
      currentStr
    ) {
      first.classList.add("in-progress");
      allPrevMerged = false;
    } else {
      allPrevMerged = false;
    }
  });
}

/* ---------- 全行結合完了判定 ---------- */
function allMerged() {
  return [...gameArea.children].every(lineDiv => {
    const idx   = Number(lineDiv.dataset.index);
    const first = lineDiv.querySelector(".inline-item");
    return first &&
           first.classList.contains("merged") &&
           first.dataset.words === originalData[idx].join("@@");
  });
}

/* ---------- 成功演出 ---------- */
function flashSuccess() {
  document.body.classList.add("flash-success");
  setTimeout(() => document.body.classList.remove("flash-success"), 800);
}
</script>
</body>
</html>
