<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>暗記ツール</title>
  <!-- PWA対応の追加要素 -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#d0ebff">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    textarea {
      width: 100%;
      height: 100px;
      font-size: 0.9rem;
    }
    button {
      font-size: 0.9rem;
      margin: 5px 3px;
    }
    .line-block {
      border: 1px solid #aaa;
      /* padding: 5px; */
      padding: 5px 15px;
      margin: 10px 0;
      background: #f9f9f9;
      display: flex;
      flex-wrap: wrap;
    }
    .inline-item {
      margin: 3px;
      padding: 6px 10px;
      background: #eee;
      border: 1px solid #888;
      cursor: pointer;
    }
    .selected-line {
      background-color: #d0ebff !important;
    }
    .in-progress {
      background: #d0ebff !important;
    }
    .merged {
      background: #fff !important;
    }
    .incorrect {
      background: #ccc !important;
    }

    body.flash-success {
      animation: flashGreen 0.8s ease-in-out;
    }

    @keyframes flashGreen {
      0% { background-color: #d4edda; }
      100% { background-color: white; }
    }
  </style>
</head>
<body>

<h3>暗記ツール</h3>

<div>
  <input type="file" id="fileInput" accept=".txt">
</div>
<textarea id="inputText" placeholder="例: これは@@最初の@@文です\n次の@@行です"></textarea><br>
<button onclick="startGame()">スタート</button>
<button onclick="showInput()">再表示</button>

<div id="gameArea"></div>

<script>
// Service Worker 登録
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js')
    .then(reg => console.log('SW登録成功:', reg))
    .catch(err => console.warn('SW登録失敗:', err));
}

let originalData = [];
let selectedLine = null;

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

document.getElementById("fileInput").addEventListener("change", function(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    document.getElementById("inputText").value = e.target.result;
  };
  reader.readAsText(file, "UTF-8");
});

function startGame() {
  const text = document.getElementById("inputText").value.trim();
  if (!text) return;
  originalData = text.split("\n").map(line => line.split("@@"));

  const gameArea = document.getElementById("gameArea");
  gameArea.innerHTML = "";

  const shuffledLines = [...originalData];
  shuffleArray(shuffledLines);

  shuffledLines.forEach((line, index) => {
    const lineDiv = document.createElement("div");
    lineDiv.className = "line-block";
    lineDiv.dataset.index = originalData.indexOf(line);
    lineDiv.addEventListener("click", () => onLineClick(lineDiv));

    const [head, ...rest] = line;
    const restShuffled = [...rest];
    shuffleArray(restShuffled);
    const items = [head, ...restShuffled];

    items.forEach(word => {
      const span = document.createElement("span");
      span.className = "inline-item";
      span.textContent = word;
      span.dataset.words = word;
      span.addEventListener("click", e => {
        e.stopPropagation();
        onWordClick(span);
      });
      lineDiv.appendChild(span);
    });

    gameArea.appendChild(lineDiv);
  });
  document.getElementById("inputText").style.display = "none";
  updateAllProgressStyles();
}

function showInput() {
  document.getElementById("inputText").style.display = "block";
}

function onLineClick(lineDiv) {
  if (!selectedLine) {
    selectedLine = lineDiv;
    lineDiv.classList.add("selected-line");
  } else {
    if (selectedLine !== lineDiv) {
      const parent = document.getElementById("gameArea");
      const lines = Array.from(parent.children);
      const i1 = lines.indexOf(selectedLine);
      const i2 = lines.indexOf(lineDiv);
      if (i1 !== -1 && i2 !== -1) {
        parent.insertBefore(selectedLine, i1 < i2 ? lineDiv.nextSibling : lineDiv);
      }
    }
    selectedLine.classList.remove("selected-line");
    selectedLine = null;
    updateAllProgressStyles();
  }
}

function onWordClick(span) {
  const lineDiv = span.parentNode;
  const lineIndex = parseInt(lineDiv.dataset.index);
  const visualIndex = Array.from(document.getElementById("gameArea").children).indexOf(lineDiv);

  const correctLine = document.getElementById("gameArea").children[lineIndex];
  if (lineDiv !== correctLine) return;

  if (visualIndex > 0) {
    const prevLine = document.getElementById("gameArea").children[visualIndex - 1];
    const prevItems = prevLine.querySelectorAll(".inline-item");
    const originalIndex = parseInt(prevLine.dataset.index);
    if (prevItems.length !== 1 || prevItems[0].dataset.words !== originalData[originalIndex].join("@@")) return;
  }

  if (visualIndex === 0) {
    const currentItems = lineDiv.querySelectorAll(".inline-item");
    const original = originalData[lineIndex];
    if (currentItems.length === 1 && currentItems[0].dataset.words === original.join("@@")) return;
  }

  lineDiv.querySelectorAll(".inline-item").forEach(el => {
    el.classList.remove("incorrect");
  });

  const answer = originalData[lineIndex];
  const items = Array.from(lineDiv.querySelectorAll(".inline-item"));
  const current = items[0];

  const currentWords = current.dataset.words.split("@@");
  const nextWord = answer[currentWords.length];

  if (span === current || span.classList.contains("merged")) return;

  if (span.textContent === nextWord) {
    current.dataset.words += "@@" + nextWord;
    current.textContent += nextWord;
    lineDiv.removeChild(span);
    updateAllProgressStyles();
  } else {
    span.classList.add("incorrect");
  }
}

function updateAllProgressStyles() {
  const gameArea = document.getElementById("gameArea");
  const lines = Array.from(gameArea.children);

  let allPreviousMerged = true;

  lines.forEach((lineDiv, visualIndex) => {
    const index = parseInt(lineDiv.dataset.index);
    const items = lineDiv.querySelectorAll(".inline-item");
    const first = items[0];
    const currentText = first ? first.dataset.words : "";
    const correctText = originalData[index].join("@@");

    items.forEach(el => {
      el.classList.remove("in-progress", "merged");
    });

    const isMerged = (
      items.length === 1 &&
      visualIndex === index &&
      currentText === correctText &&
      allPreviousMerged
    );

    if (isMerged) {
      first.classList.add("merged");
    } else if (
      allPreviousMerged &&
      visualIndex === index &&
      currentText.length > 0 &&
      correctText.startsWith(currentText)
    ) {
      first.classList.add("in-progress");
      allPreviousMerged = false;
    } else {
      allPreviousMerged = false;
    }
  });

  if (checkAllMerged()) {
    document.body.classList.add("flash-success");
    setTimeout(() => {
      document.body.classList.remove("flash-success");
    }, 800);
  }
}

function checkAllMerged() {
  const gameArea = document.getElementById("gameArea");
  const lines = Array.from(gameArea.children);
  return lines.every(lineDiv => {
    const index = parseInt(lineDiv.dataset.index);
    const items = lineDiv.querySelectorAll(".inline-item");
    const first = items[0];
    const currentText = first ? first.dataset.words : "";
    const correctText = originalData[index].join("@@");
    return (
      items.length === 1 &&
      currentText === correctText &&
      Array.from(first.classList).includes("merged")
    );
  });
}
navigator.serviceWorker.addEventListener('controllerchange', () => {
  window.location.reload(); // SW切り替え時にリロード
});
</script>

</body>
</html>
